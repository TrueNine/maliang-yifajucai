---
globs: backend/**/db/migration/**/*.sql,backend/**/*Repository.kt,backend/**/entities/**/*.kt
---

# 数据库和迁移指南

## Flyway 迁移规范

### 迁移脚本命名
- **格式**：`V{version}__{description}.sql`
- **版本号**：使用递增的整数，建议从 3000 开始
- **描述**：使用英文，单词间用下划线分隔

```
V3001__create_user_table.sql
V3002__add_email_index_to_user.sql
V3003__alter_user_add_phone_column.sql
```

### 迁移脚本位置
- **路径**：`backend/src/main/resources/db/migration/`
- **环境分离**：生产和开发使用相同的迁移脚本
- **版本控制**：所有迁移脚本必须提交到版本控制

### 迁移脚本编写规范

#### 表创建
```sql
-- V3001__create_user_table.sql
CREATE TABLE IF NOT EXISTS users (
    id BIGSERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    username VARCHAR(100) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);

-- 创建索引
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);

-- 添加注释
COMMENT ON TABLE users IS '用户表';
COMMENT ON COLUMN users.email IS '用户邮箱';
COMMENT ON COLUMN users.username IS '用户名';
```

#### 表结构变更
```sql
-- V3002__alter_user_add_phone_column.sql
ALTER TABLE users 
ADD COLUMN IF NOT EXISTS phone VARCHAR(20);

-- 添加约束
ALTER TABLE users 
ADD CONSTRAINT IF NOT EXISTS chk_phone_format 
CHECK (phone ~ '^\+?[1-9]\d{1,14}$');

-- 添加注释
COMMENT ON COLUMN users.phone IS '用户手机号';
```

#### 数据迁移
```sql
-- V3003__migrate_user_status_data.sql
-- 添加新列
ALTER TABLE users 
ADD COLUMN IF NOT EXISTS status VARCHAR(20) DEFAULT 'ACTIVE';

-- 迁移现有数据
UPDATE users 
SET status = 'ACTIVE' 
WHERE status IS NULL;

-- 添加非空约束
ALTER TABLE users 
ALTER COLUMN status SET NOT NULL;
```

### 迁移最佳实践

#### 安全原则
- **向后兼容**：新迁移不应破坏现有功能
- **可回滚**：考虑数据回滚的可能性
- **幂等性**：使用 `IF NOT EXISTS`、`IF EXISTS` 等
- **事务性**：每个迁移脚本在单个事务中执行

#### 性能考虑
- **大表变更**：分批处理，避免长时间锁表
- **索引创建**：使用 `CONCURRENTLY` 选项（PostgreSQL）
- **数据迁移**：大量数据迁移考虑分步执行

```sql
-- 并发创建索引
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_users_created_at 
ON users(created_at);
```

## Jimmer 实体设计

### 实体类规范
```kotlin
@Entity
@Table(name = "users")
interface User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long
    
    @Column(name = "email", nullable = false, unique = true)
    val email: String
    
    @Column(name = "username", nullable = false)
    val username: String
    
    @Column(name = "created_at")
    val createdAt: LocalDateTime
    
    @Column(name = "updated_at")
    val updatedAt: LocalDateTime
}
```

### 关联关系
```kotlin
@Entity
interface User {
    // ... 其他字段
    
    @OneToMany(mappedBy = "user")
    val orders: List<Order>
    
    @ManyToOne
    @JoinColumn(name = "role_id")
    val role: Role?
}
```

### 实体验证
```kotlin
@Entity
interface User {
    @Column(nullable = false)
    @Email
    val email: String
    
    @Column(nullable = false)
    @Size(min = 3, max = 50)
    val username: String
}
```

## 数据库配置

### 连接池配置
```yaml
spring:
  datasource:
    hikari:
      minimum-idle: 5
      maximum-pool-size: 15
      idle-timeout: 300000
      max-lifetime: 1200000
      connection-timeout: 20000
      auto-commit: false
```

### Flyway 配置
```yaml
spring:
  flyway:
    baseline-version: 3000
    baseline-on-migrate: true
    out-of-order: true
    validate-on-migrate: true
    locations: classpath:db/migration
```

## Repository 层设计

### 基础 Repository
```kotlin
@Repository
interface UserRepository : JRepository<User, Long> {
    
    // 使用 Jimmer 的类型安全查询
    fun findByEmail(email: String): User?
    
    // 自定义查询方法
    fun findActiveUsers(): List<User>
}
```

### 复杂查询
```kotlin
@Repository
class UserRepositoryImpl : UserRepository {
    
    fun findUsersByCondition(condition: UserCondition): List<User> {
        return sql
            .createQuery(User::class) {
                where(condition.email?.let { table.email eq it })
                where(condition.status?.let { table.status eq it })
                orderBy(table.createdAt.desc())
            }
            .execute()
    }
}
```

## 数据库测试

### 测试数据准备
```kotlin
@TestMethodOrder(OrderAnnotation::class)
class UserRepositoryTest {
    
    @Test
    @Order(1)
    @Sql("/test-data/users.sql")
    fun `应该能够查询用户列表`() {
        val users = userRepository.findAll()
        assertThat(users).hasSize(3)
    }
}
```

### Testcontainers 集成
```kotlin
@Testcontainers
class DatabaseIntegrationTest {
    
    companion object {
        @Container
        val postgres = PostgreSQLContainer("postgres:15")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test")
    }
    
    @Test
    fun `数据库连接测试`() {
        assertTrue(postgres.isRunning)
    }
}
```

## 数据库维护

### 监控和性能
- 定期检查慢查询日志
- 监控数据库连接池使用情况
- 定期更新表统计信息

### 备份策略
- 定期全量备份
- 增量备份和事务日志备份
- 备份恢复测试

### 索引优化
- 根据查询模式创建合适的索引
- 定期检查未使用的索引
- 监控索引使用统计

## 常见问题和解决方案

### 迁移失败处理
```bash
# 查看迁移状态
./gradlew flywayInfo

# 修复失败的迁移
./gradlew flywayRepair

# 清理数据库（仅开发环境）
./gradlew flywayClean
```

### 数据类型选择
- **主键**：使用 `BIGSERIAL` 或 `UUID`
- **时间戳**：使用 `TIMESTAMP WITH TIME ZONE`
- **文本**：根据长度选择 `VARCHAR(n)` 或 `TEXT`
- **布尔值**：使用 `BOOLEAN`
- **JSON 数据**：使用 `JSONB`（PostgreSQL）

### 性能优化建议
- 合理使用索引，避免过度索引
- 大表分区策略
- 查询优化和执行计划分析
- 连接池参数调优
